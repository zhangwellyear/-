## 类型转换
对于`byte`/`short`/`char`三种类型来说，如果右侧赋值的数值没有超过范围，会自动强制类型转换
`byte`/`short`涉及到运算会自动提升为`int`类型

## 变量赋值
赋值时，若右侧表达式中都是常量，编译时就会直接计算出结果

## 文件层次
项目 -> 模块 -> 包 -> 文件

## 函数定义
1. 定义顺序无关
2. 方法定义不能嵌套
3. 定义在类中
4. return的返回值必须与定义的方法类型一致
5. 对于一个void么有返回值的方法，不写return后面的返回值

## 函数重载
### 方法重载与下列因素相关
1. 参数不同
2. 参数类型不同
3. 参数的多类型顺序不同

### 方法重载与下列因素无关
1. 与参数名无关
2. 与返回值类型无关

## 数组
### 概念
一个容器，可以存放多个数据值

### 特点
1. 引用类型
2. 数组元素的类型必须统一
3. 数组长度在程序运行期间不可改变

### 两种常见的初始化方式
1. 动态初始化（指定长度）
2. 静态初始化（指定内容）

#### 动态初始化基本格式
`数据类型[] 数组名称 = new 数据类型[数组长度]`

#### 默认值
动态初始化数组时，其中元素会自动拥有一个默认值，默认规则如下：
1. 整数类型，默认为0
2. 浮点类型，默认为0.0
3. 字符类型，默认为'\u0000'
4. 布尔类型，默认为`false`
5. 引用类型，默认为`null`

#### 静态初始化基本格式
`数据类型[] 数组名称 = new 数据类型[] { 元素1， 元素2 }`

### 注意事项
1. 静态初始化没有给长度，但会自动推算长度
2. 静态初始化标准格式可以拆分成两个步骤
3. 动态初始化也可以分为两个步骤
4. 静态初始化一旦使用省略模式，就不能拆分成两个步骤了

## `Java`内存
分为五个部分：
1. 栈（stack）：存放的都是方法中的局部变量，方法运行一定要在栈中
   局部变量：方法的参数，或者是方法{}内部的变量
   作用域：一旦超出作用域，立刻从栈内存中消失
2. 堆（Heap）：凡是`new`出来的东西，都在堆中
   堆内存里面的东西都有一个地址值：16进制
   堆内存里面的数据，都有默认值，规则：
    整数    默认为0
    浮点数  默认为0.0
    字符    默认为'\u0000'
3. 方法区（Method Area）：存储class相关信息，包含方法的信息。
4. 本地方法栈（Native Method Stack）；与操作系统相关
5. 寄存器（pc Register）：与CPU相关

## 类
### 成员变量
   ```java
   String name;   // 姓名
   int age;       // 年龄
   ```
### 成员方法
   ```java
   public void eat() {

   }
   ```

### 使用类的步骤
1. 导包，也就是指出需要使用的类在哪儿（在同一个包下的类可以省略导包语句）
2. 通过`new`创建类
3. 用，`.`运算符使用
成员变量没有赋值，将会有一个默认值，规则和数组一样

### 局部变量和成员变量
1. 定义的位置不一样
   局部变量：方法内部
   成员变量：方法外部，直接写在类中
2. 作用范围不一样
   局部变量：只有方法中可以使用，出了方法不再使用
   成员变量：整个类都可以通用
3. 默认值不一样
   局部变量：没有默认值，如果想使用，必须进行手动赋值
   成员变量：如果没有赋值，会有默认值，规则与数组一样
4. 内存的位置不同
   局部变量：跟着方法走，位于栈内存
   成员变量：在创建对象时创建成员变量，位于堆内存
5. 生命周期
   局部变量：跟着方法走，随着对象出栈而消失
   成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失

## 面向对象
### 三大特性
封装、继承、多态

### 访问`private`变量
定义一对`Getter/Setter`方法

必须叫`setXXX`或者`getXXX`命名规则
`boolean`类型的`get`应该用`isXXX`

### `this`
通过谁调用的方法，谁就是`this`

### 构造方法
1. 方法名称与类名一致（包括大小写）
2. 构造方法没有返回值类型
3. 构造方法不能return值
4. 没有构造方法，默认会添加
5. 有自编写构造函数，不会再使用默认的构造方法

### 标准类的四个组成部分
1. 所有成员变量都使用`private`修饰
2. 每个变量都编写一对`Setter/Getter`方法
3. 编写一个无参数的构造方法
4. 编写一个全参数的构造方法

## api
### `Scanner`
`Scanner`类的功能，可实现键盘输入数据到程序

### 引用类型的一般步骤：
1. 导包（`java.lang`包下面的内容不需要导包，可以直接使用）
2. 创建
   类名称 对象名 = new 类名称
3. 使用
   对象名.成员方法名

### `ArrayList`
`ArrayList`使用时，跟着一个尖括号表示泛型，如一个`String`类型的`ArrayList`，可以通过`ArrayList<String>`来表示

对于`ArrayList`来说，直接打印得到的不是地址值，而是内容

### 包装类与基本类型的对照
| 基本类型 | 包装类 |
| -- | -- |
| byte | Byte |
| short | short |
| int | Integer |
| long | Long |
| float | Float |
| double | Double |
| char | Character |
| boolean | Boolean |

## 字符串
### 字符串常量池
`new`的不在常量池中
直接赋值的字符串在常量池中

### 字符串中的常用方法
`equals`: 内容是否相等，推荐使用一个字面量字符串.equals(字符串变量)
`concat`: 不改变原字符串，返回一个全新的结果
`toCharArray`: 将当前字符转换为一个`char`类型数组
`getBytes`: 获取字符串对应的`char`类型数组的`bytes`类型数组

### 静态代码块
+ 静态代码总是优先于动态代码块执行，静态代码块比构造代码先执行
+ 静态代码执行唯一的一次